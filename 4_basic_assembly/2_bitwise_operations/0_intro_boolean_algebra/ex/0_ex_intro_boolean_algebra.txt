Basic Assembly
==============

Bitwise operations
------------------

Introduction to boolean algebra
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Welcome to the "Introduction to boolean algebra" exercises section.
We use the following symbols in this exercise:

V - OR
^ - AND
! - NOT
+ - XOR


0.  Calculate the following expressions:

    0.0   !0                                                = 1
    0.1   (!0)^1 = 1^1                                      = 1
    0.2   (0^1)V(!0) = 0V1                                  = 1 
    0.3   0V1V0V0                                           = 1
    0.4   1+1                                               = 0
    0.5   ((!1)^(0V1))V((!0)^(1^1)) = (0^1)V(1^1) = 0V1     = 1
    0.6   (0+1)^(1+0) = 1^1                                 = 1


1.  Build truth tables and Venn diagrams for the following expressions:

    1.0   (!a)Va
    a       (!a)Va
    0       1
    1       1

    1.1   (!a)^a
    a       (!a)^a
    0       0
    1       0

    1.2   (!a)^b
    ab      (!a)^b
    00      0
    01      1
    10      0
    11      0

    1.3   aVbVc
    abc     aVbVc
    000     0
    001     1
    010     1
    011     1
    100     1
    101     1
    110     1
    111     1

    1.4   ((!a)^b)V((!b)^a) -> a + b
    ab      !a^b  !b^a  ((!a)^b)V((!b)^a)
    00      0     0     0
    01      1     0     1
    10      0     1     1
    11      0     0     0

    1.5   !((!a)V(!b)) -> a^b
    ab      !aV!b       !((!a)V(!b))
    00      1           0
    01      1           0
    10      1           0
    11      0           1


2.  Basic properties:
    Prove the following statements. This could be done, for example, using Truth
    tables.

    2.0   OR's Associative law: aV(bVc) = (aVb)VC
    abc     aVb   bVc   aV(bVc)     (aVb)VC
    000     0     0     0           0
    001     0     1     1           1
    010     1     1     1           1
    011     1     1     1           1
    100     1     0     1           1
    101     1     1     1           1
    110     1     1     1           1
    111     1     1     1           1

    2.1   Distributive law: aV(b^c) = (aVb)^(aVc)
    abc     b^c   aVb   aVc   aV(b^c)     (aVb)^(aVc)
    000     0     0     0     0           0
    001     0     0     1     0           0
    010     0     1     0     0           0
    011     1     1     1     1           1
    100     0     1     1     1           1
    101     0     1     1     1           1
    110     0     1     1     1           1
    111     1     1     1     1           1

    2.2   De Morgan's law: aVb = !((!a)^(!b))
    ab      !a^!b       aVb   !(!a^!b)
    00      1           0     0
    01      0           1     1
    10      0           1     1
    11      0           1     1

    2.3   XOR's associative law: (a+b)+c = a+(b+c)
    abc     a+b   b+c   (a+b)+c     a+(b+c)
    000     0     0     0           0
    001     0     1     1           1
    010     1     1     1           1
    011     1     0     0           0
    100     1     0     1           1
    101     1     1     0           0
    110     0     1     0           0
    111     0     0     1           1

    2.4   AND and XOR distributive law: a^(b+c) = (a^b)+(a^c)
    abc     b+c   a^b   a^c   a^(b+c)     (a^b)+(a^c)
    000     0     0     0     0           0
    001     1     0     0     0           0
    010     1     0     0     0           0
    011     0     0     0     0           0
    100     0     0     0     0           0
    101     1     0     1     1           1
    110     1     1     0     1           1
    111     0     1     1     0           0

3.  Representing operators using other operators.
    
    3.0   How could you represent a^b using the ! and V operators?      !aV!b
          How could you represent aVb using the ! and ^ operators?      !a^!b

    3.1   Representing !:
      3.1.0   Show that in any expression that contains only the operators ^ and
              V, if all the variables are 0 then the result is 0.
              
              0^0 = 0
              0V0 = 0
              Therefore, there is no way to get a 1, if all inputs are zeros.

      3.1.1   Prove that !a could not be represented using only the ^ and V
              operators.

              !a requires the ability to go from 0 to 1.  As shown above, this is not possible.

4.  Bonus: Disjunctive normal form.

    4.0   Create an expression E(a,b) with the variables a,b and with the
          operators ^,V,! that has the following property: E(a,b) = 1 only if
          a=0 and b=1. (It is 0 otherwise).

          ab o    !a^b
          00 0    0
          01 1    1
          10 0    0
          11 0    0

    4.1   Create an expression T(a,b,c) with the variables a,b,c that has the
          following property: T(a,b,c) = 1 only if a=1,b=0,c=1.

          abc o   a^c^!b
          000 0   0
          001 0   0
          010 0   0
          011 0   0
          100 0   0
          101 1   1
          110 0   0
          111 0   0

    4.2   Create an expression G(a,b,c,d) with the variables a,b,c,d that has
          the following property: G(a,b,c,d) = 1 only if a=0,b=1,c=1,d=0.

          !a^b^c^!d

    4.3   Describe how to create an expression Q(a_1,a_2,...,a_s) that
          has the following property: Q(a_1,a_2,...,a_s) = 1 only if a_1=k_1,
          a_2=k_2 , ... , a_s=k_s for some constant bits k_1,...,k_s.

          kn = 1, an
          kn = 0, !an
          combine with AND

    4.4   Every operator L(a_1,a_2,...,a_s) with variables a_1,...,a_s has a
          truth table that could be calculated for every assignment of values
          into the variables a_1,...,a_s.

          Given the truth table of the operator L, infer how to create an
          expression that equals the operator L for every choice of values for
          a_1,...,a_s.

          Follow the method in 4.3 for every valid set.  Combine those sets with OR

    4.5   Conclude that ^,V,! could be used to represent any possible boolean
          operator.

          Infer using 3.0 that either {^,!} or {V,!} would be enough.

          Given 4.4, it is clear that any other operator can be built up from
          the basic operators: ^,V,!


5.  The XOR operator.

    5.0   Show that !x = x+1
    x       1     !x    x+1
    0       1     1     1
    1       1     0     0

    5.1   Find 5 bits a_1,a_2,a_3,a_4,a_5 such that each bit a_i equals to the
          XOR of the rest of the bits.

          Bonus:  Could you do the same for any n bits? 
                  How many such sets of n bits exist?

      00000, unless there are special rules for single digits, this is the only value that works.
      There are infinite streams of zeros.

      If nil and one bit are 'wild' and can be whatever is needed for a true evaluation, then:
      11011 is also a valid entry, and sets of repeating 011 are valid streams.

      Either way, there are still an infinite number of sets, given infinitely long input.

    5.2   Find a representation for aVb using the operator ^, the operator +
          (XOR) and the bit 1.

          HINT: Use the solution of question 5.0.

          a^!bVb^!a
          (!aVb)^(!bVa)

    5.3   Infer that every expression that can be represented using V,^,! could
          be represented using +(XOR),^ and the number 1.

          aVb = (a^b)+(a+b)
          ab a^b   !     a+b   !     aVb  a^b   !a    a+1
          00 0     1     0     1     0    0     1     1
          01 0     1     1     0     1    0     1     1
          10 0     1     1     0     1    0     0     0
          11 1     0     0     1     1    1     0     0

          a+1 -> !a
          a^b is trivial, given we already have AND
          aVb is more complex, but solvable given the primitives (see above)

          Therefore these can be composed to solve any equation using V^!

          Bonus: Show (Using the distributive property of XOR and AND) that we
          need at most one instance of the number "1" in such expression.

          a^(b+c) = (a^b)+(a^c)

          1) We use 1 for negation (n+1 -> !n) (!(n+1) -> n) (n+1+1 -> n).
          2) Negation of an AND yields an OR, which we can represent with only AND and XOR
          3) Negation of an OR yields an AND, which we can represent with only an AND
          4) If the negations are even, then we can remove *all* negations via 2 and 3
          5) If the negation are odd, all paired negations can be removed via 4, leaving a single negation remaining
          6) In the same way we can remove paired expressions, we can remove paired single-variable negation
          7) 1, 5, & 6 mean that we can reduce any expression to AT MOST, one '1'

    5.4   Find all the solutions to the following set of equations, in a,b,c.
          Note that each solution (a,b,c) that you find should satisfy all the
          three equations at the same time.

          (Recall that here + means XOR)
          
          a + b = 1     a = !b
          b + c = 1     b = !c
          a + c = 0     a = c

          abc     a+b   b+c   !(a+c)      (a^!b)^(b^!c)^!(a+c)
          000     0     0     1           0
          001     0     1     0           0
          010     1     1     1           1
          011     1     0     0           0
          100     1     0     0           0
          101     1     1     1           1
          110     0     1     0           0
          111     0     0     1           0

          010, 101


6.  Simplify the following expressions:
    You may use any of the laws that we have learned about, use truth tables,
    Venn diagrams or even try to guess.

    You can use Truth tables to make sure that your answer is correct.

    
    6.0   (a^b)V(aVb)
    ab      (a^b) (aVb) (a^b)V(aVb)
    00      0     0     0
    01      1     1     1
    10      1     1     1
    11      0     1     1

      aVb

    6.1   (aVb)^(!((!a)^(!b)))
    (aVb)^(!((!a)^(!b))) -> aVb ^ aVb -> aVb

    6.2   (!((a^b)V(!c)))+c
    (!((a^b)V(!c)))+c -> (aVb ^ c) + c -> note, *^c can only be true when c is.  c + c -> 0

    6.3   (b^(!(a^b)))Va
    ab      !(a^b)      (b^(!(a^b)) (b^(!(a^b)))Va
    00      1           0           0
    01      1           1           1
    10      1           0           1
    11      0           0           1

    aVb

7.  Bonus: The NAND operator.
    
    We define the binary operator NAND as following:
    a NAND b = !(a^b)
    (NAND is a shorthand for NOT AND).

    7.0   Write a truth table for the NAND operator.
    ab NAND
    00 1
    01 1
    10 1
    11 0

    7.1   Find a way to represent !a only using the NAND operator.

    a NAND 1

    7.2   Find a way to represent a^b only using the NAND operator.

    ab      aN1   bN1   aNb   aN(bN1)     (aN1)Nb     (aN1)N(bN1) aNbN1
    00      1     1     1     0           1           0           0
    01      1     0     1     1           0           1           0
    10      0     1     1     1           1           1           0
    11      0     0     0     1           1           1           1

      (a NAND b) NAND 1

    7.3   As in 4, Conclude that the NAND operator could be used to represent
          any boolean operator.

      !a    -> a NAND 1
      a^b   -> a NAND b NAND 1
      aVb   -> (a NAND 1) NAND (b NAND 1)
      
      These three are the basic building blocks of all other logic operators.
      Thus, NAND can be anything.

8.  Bonus: Counting boolean operators.

    8.0   How many possible boolean operators are there which have one bit
          argument, and one bit output?

          4:      i ->  0
                  i ->  1
                  i ->  i
                  i -> !i

          How many are there with two bit arguments, and one bit output?

          16: 0, a, b, a^b, aVb, a+b, !a+b, !aVb (x2, for NOT)

    8.1   How many possible boolean operators with k arguments and one bit
          output exist?

          2^(2k)


Have fun :)
